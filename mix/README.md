# fp3e2m1
---

### 1. fp4e2m1 格式的结构
根据假设，fp4e2m1 是一个 4 位浮点数格式，位分配如下：
- **1 位符号位（s）**：表示数的正负（0 为正，1 为负）。
- **2 位指数位（e）**：表示指数部分，通常有偏置（bias）。
- **1 位尾数位（m）**：表示尾数的小数部分，隐含前导 1（归一化）。

浮点数的值计算公式为：
 (-1)^s * M * 2 ^ (e - bias)

其中：
- M = 1.m（尾数，归一化形式，例如 m=1时，M = 1.1{2} = 1.5{10}
- 偏置（bias）通常为 2^{n-1} - 1 = 2^{2-1} - 1 = 1，其中n是指数位数。

---

### 2. 内存中的分布
由于 fp4e2m1 是 4 位格式，我们假设这 4 位在内存中按顺序存储，通常按照以下布局（类似 IEEE 754 浮点数的惯例）：
- **高位到低位**：符号位、指数位、尾数位。
- 具体分布：
  - **第 3 位（最高位）**：符号位 \( s \)。
  - **第 2-1 位**：指数位 \( e \)。
  - **第 0 位（最低位）**：尾数位 \( m \)。

**内存布局示例**：
- 假设一个 fp4e2m1 数值为 (0101)：
  - 位分布：\( s = 0 \)，\( e = 10 \)，\( m = 1 \)。
  - 在内存中，这 4 位按顺序存储为：

    | 位 3 | 位 2 | 位 1 | 位 0 |
    | -- | -- | -- | -- |
    |  s   |  e1  |  e0  |  m   |
    |   0  |   1  |   0  |  1   |

  - 物理存储：从高位到低位为 \( 0101 \)。

#### 存储单位
- **4 位存储**：4 位（半个字节）是 fp4e2m1 的最小存储单位。
- 在实际计算机系统中，数据通常以字节（8 位）为最小寻址单位，因此 fp4e2m1 可能需要嵌入更大的存储结构（例如，与其他数据一起打包在一个字节或字中）。
- 如果存储在字节中，可能需要额外的填充位（padding）或与其他 4 位数据组合。例如：
  - 一个字节可能存储两个 fp4e2m1 数：\[ 4 位 fp4e2m1 | 4 位 fp4e2m1 \]。
  - 填充方式取决于具体实现（例如，高 4 位或低 4 位）。

---

### 3. 内存分布的细节
#### a. 位顺序
- **高位优先（Big-Endian）**：符号位在最高位，尾数位在最低位，如上例的 \( 0101_2 \)。
- **低位优先（Little-Endian）**：位顺序可能反转（\( 1010_2 \)），但这取决于底层硬件架构。现代系统中，浮点数通常遵循高位优先的 IEEE 754 标准布局。
- 由于 fp4e2m1 是自定义格式，具体位顺序需参考其定义规范。如果未指定，通常假设高位优先（符号位在最左）。

#### b. 特殊值
- **零**：可能由 \( e = 00_2 \)，\( m = 0 \) 表示（具体取决于实现是否支持非规格化数）。
- **无穷大/NaN**：由于只有 2 位指数，\( e = 11_2 \) 可能表示特殊值，但 1 位尾数限制了 NaN 的定义，可能简化为仅表示无穷大。

---